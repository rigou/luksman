#!/bin/bash
# luksman : a simple manager for LUKS encrypted volumes
# download the latest version of this program : https://github.com/rigou/luksman/releases
#
# This program is free software: you can redistribute it and/or modify it under the terms
# of the GNU General Public License as published by the Free Software Foundation, version 3.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.
# See the GNU General Public License for more details : https://www.gnu.org/licenses/#GPL 
#
# Installation, usage : https://github.com/rigou/luksman/blob/main/README.md
# Run this script as root (sudo)

set -o nounset

readonly APPNAME='luksman'
readonly VERSION='1.3.0'

# output user-readable messages
declare -i stdin=1
declare -i stderr=2
function print_line {
	if [ "$1" -eq $stdin ] ; then
		echo "$2"
	else
		echo "$2" 1>&2
	fi
}

function get_key_device {
	local keydev_from_label=''
	if [ -n "$KeyLabel" ] ; then
		keydev_from_label=$(readlink -fe "/dev/disk/by-label/$KeyLabel")
		if [ -n "$keydev_from_label" ] ; then
			echo "$keydev_from_label" # empty string if label not found
		fi
	elif [ -n "$KeyDev" ] ; then
		echo "$KeyDev"
	fi
}

function get_temp_keyfile {
	echo "$KeyFile.tmp"
}

function validate_temp_keyfile {
	print_line $stdin "validating new key file"
	mv -f "$(get_temp_keyfile)" "$KeyFile"
	return $?
}

function delete_all_temp_keyfiles {
	find "$(dirname "$KeyFile")"  -name '*\.tmp' -exec rm "{}" \;
}

# Store a randomly generated 33 char key in a file
# we create the key using a 90 ascii printable char set
# a 33 char key lengths gives 3 x 10^64 distinct keys
# Since v1.1.4 the key string is not terminated by \n, enabling us to enter it with the keyboard if so desired
# Lucks will use our key to unlock the master-key of the encrypted device
# (passphrases can be up to 512 characters and keyfiles up to 8192 KiB)
function create_temp_keyfile {
	local -i retval_int=0 # success
	local temp_keyfile ; temp_keyfile=$(get_temp_keyfile)
	print_line $stdin "generating new key file"
	local key ; key=$(LC_ALL=C tr -dc 'A-Za-z0-9_\+\-*/=,?;.:/!$&#{[|]}@%&$"~^' < /dev/random | head -c 33)
	mkdir -p "$(dirname "$temp_keyfile")"
	if ! echo -n "$key" >"$temp_keyfile" ; then
		retval_int=1 # error
	fi
	return $retval_int
}

function mount_key {
	local -i retval_int=0 # 0=success, 1=error
	if ! mountpoint -q "$KeyMountPoint" ; then
		mount "$KeyDev" "$KeyMountPoint"
		retval_int=$?
	fi
	return $retval_int
}

function unmount_key {
	local -i retval_int=0 # 0=success, 1=error
	if mountpoint -q "$KeyMountPoint" ; then
		delete_all_temp_keyfiles
		umount "$KeyMountPoint"
		retval_int=$?
	else
		print_line $stderr "key not found at $KeyMountPoint"
		retval_int=0 # ignore this error
	fi
	return $retval_int
}

# Tell if given volume name corresponds to an attached loop device
# Return value: 0=attached, 1=not attached or not a loop device
function is_attached_loop_device {
	local -i retval_int ; retval_int=$(losetup --output BACK-FILE --noheadings |grep -c "/$Name.dat")
	if [ $retval_int -gt 0 ] ; then
		retval_int=0
	else
		retval_int=1
	fi
	return $retval_int
}
	
# Return values written on stdout: 			
declare -ir GVS_CLOSED=0
declare -ir GVS_MOUNTED=1	# encrypted filesystem mounted, ready for use
declare -ir GVS_FAILED1=2		# blockfile attached (if any), no LUKS open
declare -ir GVS_FAILED2=3		# blockfile attached (if any) and LUKS open but filesystem not mounted
function get_volume_status {
	local -i retval_int=$GVS_CLOSED
	local -i attached_bool=0 # 0=false, 1=true
	local -i luksopen_bool=0
	local -i mounted_bool=0
	if is_attached_loop_device ; then
		attached_bool=1
	fi
	if [ -b "$LuksMap" ] ; then
		luksopen_bool=1
	fi
	if mountpoint -q "$LuksMountPoint" ; then
		mounted_bool=1
	fi
	if [ $mounted_bool -eq 1 ] ; then
		retval_int=$GVS_MOUNTED
	else
		if [ $luksopen_bool -eq 1 ] ; then
			retval_int=$GVS_FAILED2
		elif [ $attached_bool -eq 1 ] ; then
			retval_int=$GVS_FAILED1
		fi
	fi
	echo $retval_int
}

# to get the assigned loop device name after calling this function:
# losetup -j /mnt/DATA/rigou/DEMO.dat --output NAME --noheadings
# return value: writes the device name on stdout, or 'ERROR'
function attach_blockfile {
	if [ -f "$BlockFile" ] ; then
		if ! is_attached_loop_device ; then
			print_line $stderr "attaching $BlockFile"
			local luks_dev ; luks_dev=$(losetup -f) # /dev/loop0
			if losetup "$luks_dev" "$BlockFile" ; then
				echo "$luks_dev"
			else
				echo 'ERROR'
			fi
		else
			print_line $stderr "$Name is already attached"
			echo 'ERROR'
		fi
	else
		print_line $stderr "file not found $BlockFile"
		echo 'ERROR'
	fi
	return
}

function create_luks {
	local -i retval_int=0 # success
	local luks_dev=''
	local -i attached_bool=0 # 0=false, 1=true
	local -i luksopen_bool=0 # 0=false, 1=true
	local -i keydev_mounted_bool=0 # 0=false, 1=true

	# test for existing block file with same name
	if [ -n "$BlockFile" ] && [ -f "$BlockFile" ] ; then
		print_line $stderr "can not create volume $Name because file $BlockFile already exists"
		print_line $stderr "you should delete it if you want to create another volume with the same name" 
		retval_int=1 # error
	fi

	# test for existing key file with same name
	if [ -n "$KeyDev" ] ; then
		if mount_key ; then
			keydev_mounted_bool=1
			if [ -f "$KeyFile" ] ; then
				local key_name=$KeyLabel
				if [ -z "$key_name" ] ; then
					key_name=$KeyDev
				fi
				print_line $stderr "can not create volume $Name because key file $(basename "$KeyFile") already exists"
				print_line $stderr "you should delete it from $key_name if you want to create another volume with the same name" 
				retval_int=1 # error
			fi
		else
			retval_int=1 # error
		fi
	fi

	# test for existing filesystem on the device
	if [ $retval_int -eq 0 ] && [ -n "$Device" ] ; then
		if mount -r "$Device" "$DevMountPoint" 2>/dev/null ; then
			print_line $stdin "$Device appears to contain an existing filesystem ($(findmnt -n -o FSTYPE "$DevMountPoint")) : it will be deleted"
			umount "$DevMountPoint"
			while : ; do
				read -r -p "are you sure (YES/no) ? " yn
				case $yn in
					YES) retval_int=0 ; break ;;
					no) retval_int=1 ; break ;;
					*) print_line $stdin "please answer YES or no" ;;
				esac
			done
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if [ -n "$BlockFile" ] ; then
			print_line $stdin "overwriting $BlockFile with $Size MiB random data"
			if dd if=/dev/urandom of="$BlockFile" bs=1M count=$Size ; then
				print_line $stdin "assigning $BlockFile to $Owner"
				chown "$Owner": "$BlockFile"
				luks_dev=$(attach_blockfile) # /dev/loop0
				if [ "$luks_dev" != 'ERROR'  ] ; then
					attached_bool=1 # true
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		else
			luks_dev=$Device
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if [ -n "$KeyDev" ] ; then
			if create_temp_keyfile ; then
				print_line $stdin "formatting $Name"
				if cryptsetup luksFormat --key-file="$(get_temp_keyfile)" -q "$luks_dev" ; then
					if cryptsetup open --type luks --key-file="$(get_temp_keyfile)" "$luks_dev" "$Name" ; then
						luksopen_bool=1
					else
						retval_int=1 # error
					fi
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		else
			print_line $stdin "formatting $Name"
			if cryptsetup luksFormat -q  "$luks_dev" ; then
				if cryptsetup open --type luks "$luks_dev" "$Name" ; then
					luksopen_bool=1
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if mkfs -t ext4 -L "$Name" "$LuksMap" ; then
			print_line $stdin "assigning $Name to $Owner"
			if mount "$LuksMap" "$LuksMountPoint" ; then
				chown "$Owner": "$LuksMountPoint"
				retval_int=$?
				umount "$LuksMountPoint"
				# take a short nap after umount because sometimes cryptsetup close would fail
				# with "device-mapper: remove ioctl on PRO  failed: Device or resource busy"
				sleep 2
			else
				retval_int=1 # error
			fi
		else
			retval_int=1 # error
		fi
	fi

	if [ $luksopen_bool -eq 1 ] ; then
		cryptsetup close "$LuksMap"
	fi
	if [ $attached_bool -eq 1 ] ; then
		print_line $stdin "detaching $BlockFile"
		losetup -d "$luks_dev"
	fi
	if [ -n "$KeyDev" ] ; then
		if [ $retval_int -eq 0 ] ; then
			validate_temp_keyfile
			retval_int=$?
		fi
	fi
	if [ $keydev_mounted_bool -eq 1 ] ; then
		unmount_key
	fi
	if [ $retval_int -eq 0 ] ; then
		print_line $stdin "volume $Name is created"
	fi
	return $retval_int
}

function add_or_replace_key {
	local -i retval_int=0 # success
	local luks_dev=''
	local -i attached_bool=0 # 0=false, 1=true
	if mount_key ; then
		if [ -n "$BlockFile" ] ; then
			luks_dev=$(attach_blockfile) # /dev/loop0
			if [ "$luks_dev" != 'ERROR'  ] ; then
				attached_bool=1 # true
			else
				retval_int=1 # error
			fi
		else
			luks_dev=$Device
		fi
		if [ $retval_int -eq 0 ] ; then
			if ! create_temp_keyfile ; then
				retval_int=1 # error
			fi
		fi
		if  [ $retval_int -eq 0 ] ; then
			if [ -f "$KeyFile" ] ; then
				print_line $stdin "replacing key file"
				if cryptsetup luksAddKey "$luks_dev"  --key-file "$KeyFile" "$(get_temp_keyfile)" ; then
					print_line $stdin "removing old key"
					if ! cryptsetup luksRemoveKey "$luks_dev" "$KeyFile" ; then
						print_line $stderr "WARNING: failed to remove old key for $Name"
					fi
					print_line $stdin "key replaced for $Name"
				else
					retval_int=1 # error
				fi
			else
				print_line $stdin "adding key file"
				if cryptsetup luksAddKey "$luks_dev" "$(get_temp_keyfile)" ; then
					print_line $stdin "removing old passphrase (enter invalid value to preserve it)"
					if ! cryptsetup luksRemoveKey "$luks_dev"  ; then
						print_line $stderr "WARNING: did not remove old key for $Name"
					fi
					print_line $stdin "key added to $Name"
				else
					retval_int=1 # error
				fi
			fi
		fi
		if [ $attached_bool -eq 1 ] ; then
			print_line $stdin "detaching $BlockFile"
			losetup -d "$luks_dev"
		fi
		if [ $retval_int -eq 0 ] ; then
			validate_temp_keyfile
			retval_int=$?
		fi
		unmount_key
	else
		retval_int=1 # error
	fi
	if [ $retval_int -eq 0 ] ; then
		print_line $stdin "key registration complete"
	fi
	return $retval_int
}

function mount_luks {
	local -i retval_int=0 # success
	local -i key_mounted_bool=0 # 0=false 1=true
	if [ -n "$KeyDev" ] ; then
		if mount_key ; then
			key_mounted_bool=1
			if ! [ -f "$KeyFile" ] ; then
				print_line $stderr "key file not found for $Name"
				retval_int=1
			fi
		else
			retval_int=1
		fi
	fi
	if  [ $retval_int -eq 0 ] ; then
		if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			local luks_dev=''
			if  [ $retval_int -eq 0 ] ; then
				if [ -n "$BlockFile" ] ; then
					luks_dev=$(attach_blockfile) # /dev/loop0
					if [ "$luks_dev" = 'ERROR'  ] ; then
						retval_int=1
					fi
				else
					luks_dev=$Device
				fi
			fi
			if  [ $retval_int -eq 0 ] ; then
				print_line $stdin "opening $Name"
				if [ -n "$KeyDev" ] ; then
					cryptsetup open --type luks --key-file="$KeyFile" "$luks_dev" "$Name"
				else
					cryptsetup open --type luks "$luks_dev" "$Name"
				fi
				retval_int=$?
				if [ $retval_int -eq 0 ] ; then
					print_line $stdin "mounting $Name"
					mount "$LuksMap" "$LuksMountPoint"
					retval_int=$?
				fi
			fi
			
		fi
	fi
	if [ $key_mounted_bool -eq 1 ] ; then
		unmount_key
	fi
	print_info
	return $retval_int
}

function unmount_luks {
	local -i retval_int=0 # success
	if [ "$(get_volume_status)" -ne $GVS_CLOSED ] ; then
		print_line $stdin "unmounting $Name"
		if umount "$LuksMountPoint" ; then
			# take a short nap after umount because sometimes cryptsetup close would fail
			# with "device-mapper: remove ioctl on PRO  failed: Device or resource busy"
			sleep 2
		else
			# list open files, if any
			lsof +d "$LuksMountPoint" 2>/dev/nullretval_int=1
			retval_int=1
		fi
		cryptsetup close "$LuksMap"
		retval_int+=$?
		if is_attached_loop_device ; then
			local blockfile ; blockfile=$(losetup --output BACK-FILE --noheadings |grep "/$Name.dat")
			print_line $stdin "detaching $blockfile"
			local luks_dev ; luks_dev=$(losetup -j "$blockfile" --output NAME --noheadings) # /dev/loop0
			losetup -d "$luks_dev"
			retval_int+=$?
		fi
	fi
	print_info
	return $retval_int
}

function print_info {
	local -i status_int ; status_int=$(get_volume_status)
	local open_text=''
	case $status_int in
	"$GVS_CLOSED") open_text="not mounted" ;;
	"$GVS_MOUNTED") open_text="mounted at $LuksMountPoint" ;;
	"$GVS_FAILED1") open_text="in failed state : loop device attached but LUKS not open" ;;
	"$GVS_FAILED2") open_text="in failed state : LUKS open but filesystem not mounted" ;;
	esac
	open_text="$Name is $open_text"
	if [ $status_int -eq  $GVS_FAILED1 ] || [ $status_int -eq  $GVS_FAILED2 ] ; then
		print_line $stderr "$open_text"
		print_line $stderr "try \"$(basename "$0") -u $Name\" to fix this error"
	else
		print_line $stdin "$open_text"
	fi
}

function print_list {
	local path=''
	find /dev/mapper -type l -print0 |while IFS= read -r -d '' path
	do
		local mountpoint ; mountpoint="/mnt/$APPNAME/$(basename "$path")"
		if [ -d "$mountpoint" ] ; then
			print_line $stdin "$mountpoint"
		fi
	done
}

function exec_action {
	local -i retval_int=0 # success
	case "$Action" in
	"$ACT_CREATE") 	if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			create_luks
			retval_int=$?
		else
			print_line $stderr "$Name is in use : unmount it first with \"$(basename "$0") -u $Name\""
			retval_int=1
		fi
		;;
	"$ACT_NEWKEY")	if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			add_or_replace_key
			retval_int=$?
		else
			print_line $stderr "$Name is in use : unmount it before adding/replacing a key"
			retval_int=1
		fi
		;;
	"$ACT_MOUNT")
		mount_luks
		retval_int=$?
		;;
	"$ACT_UNMOUNT")	
		if [ "$Name" = 'all' ] ; then
			local names='' ; names=$(print_list)
			if [ -n "$names" ] ; then
				for name in $names ; do
					$0 unmount "$(basename "$name")"
				done
			fi
		else
			unmount_luks
			retval_int=$?
		fi
		;;
	"$ACT_INFO")	print_info ; retval_int=0 ;;
	"$ACT_LIST")	print_list ; retval_int=0 ;;
	esac
	return $retval_int
}

#$$$$$$$$ TODO: filter Name
function usage {
	print_line $stdin "$APPNAME v$VERSION usage"
	local n0="    $APPNAME"
	print_line $stdin "create volume in a file container or a device"
	print_line $stdin "$n0 $ACT_CREATE name (-f folder -s size_MiB | -d device) [(-k keyfile_device | -K keyfile_disk_label)] -o owner_name "
	print_line $stdin "add or replace a key file"
	print_line $stdin "$n0 $ACT_NEWKEY name (-f folder | -d device) (-k keyfile_device | -K keyfile_disk_label)"
	print_line $stdin "mount volume"
	print_line $stdin "$n0 $ACT_MOUNT name (-f folder | -d device) [(-k keyfile_device | -K keyfile_disk_label)]"
	print_line $stdin "unmount volume(s)"
	print_line $stdin "$n0 $ACT_UNMOUNT (name | all)"
	print_line $stdin "print volume information"
	print_line $stdin "$n0 $ACT_INFO name"
	print_line $stdin "list mounted volumes"
	print_line $stdin "$n0 $ACT_LIST"
}

function check_args {
	local -i retval_int=1 # error
	local -ri VOLUME_MIN_SIZE=17 # because LUKS takes a 16 MiB overhead
	if [ "$Action" = $ACT_LIST ] ; then
		retval_int=0 # list takes no args
	elif [ -n "$Name" ] ; then
		# check required arguments
		case "$Action" in
		"$ACT_CREATE") if [ -n "$Folder" ] && [ -z "$Device" ] && [ $Size -ge $VOLUME_MIN_SIZE ] && [ -n "$Owner" ] ; then retval_int=0 ; fi
			if [ -n "$Device" ] && [ -z "$Folder" ] && [ -n "$Owner" ] ; then retval_int=0 ; fi
			;;
		"$ACT_NEWKEY") if [ -n "$Folder" ] && [ -z "$Device" ] && [ -n "$KeyDev" ] &&  [ -z "$KeyLabel" ] ; then retval_int=0 ; fi
			if [ -n "$Folder" ] && [ -z "$Device" ] && [ -z "$KeyDev" ] &&  [ -n "$KeyLabel" ] ; then retval_int=0 ; fi
			if [ -n "$Device" ] && [ -z "$Folder" ] && [ -n "$KeyDev" ] &&  [ -z "$KeyLabel" ] ; then retval_int=0 ; fi
			if [ -n "$Device" ] && [ -z "$Folder" ] && [ -z "$KeyDev" ] &&  [ -n "$KeyLabel" ] ; then retval_int=0 ; fi
			;;
		"$ACT_MOUNT") if [ -n "$Folder" ] && [ -z "$Device" ] ; then retval_int=0 ; fi
			if [ -n "$Device" ] && [ -z "$Folder" ] ; then retval_int=0 ; fi
			;;
		"$ACT_UNMOUNT" | "$ACT_INFO") retval_int=0 ;;
		esac
		if [ $retval_int -eq 0 ] ; then
			# check optional arguments -k -K
			if [ -n "$KeyDev" ] && [ -n "$KeyLabel" ] ; then retval_int=1 ; fi
			if [ -n "$KeyDev" ] || [ -n "$KeyLabel" ] ; then
				if [ "$Action" = "$ACT_UNMOUNT" ] || [ "$Action" = "$ACT_INFO" ] ; then
					retval_int=1
				fi
			fi
		fi
	fi
	if [ $retval_int -ne 0 ] ; then 
		print_line $stderr "missing/extra/invalid arg"
	else
		if [ -n "$Folder" ] && ! [ -d "$Folder" ] ; then print_line $stderr "folder $Folder not found" ; retval_int=2 ; fi
		if [ -n "$Device" ] && ! [ -b "$Device" ] ; then print_line $stderr "device $Device not found" ; retval_int=2 ; fi
		if [ -n "$KeyDev" ] && ! [ -b "$KeyDev" ] ; then print_line $stderr "device $KeyDev not found" ; retval_int=2 ; fi
		if [ -n "$Owner" ] && ! id "$Owner" &>/dev/null ; then print_line $stderr "user $Owner not found" ; retval_int=2 ; fi
		if [ -n "$KeyLabel" ] ; then
			# get_key_device() returns empty string if label not found
			if [ -z "$(get_key_device)" ] ; then
				print_line $stderr "device not found with label $KeyLabel"
				retval_int=2
			fi
		fi
	fi
	return $retval_int
}

# BEGIN ----------

if [ "$(id -u)" != '0' ] ; then
	print_line $stderr "$APPNAME must run as root, run it with sudo $APPNAME"
	exit 1
fi

# Parse command line args
readonly ACT_CREATE='create'
readonly ACT_NEWKEY='newkey'
readonly ACT_MOUNT='mount'
readonly ACT_UNMOUNT='unmount'
readonly ACT_INFO='info'
readonly ACT_LIST='list'
if [ $# -eq 0 ] ; then
	usage
	exit 1
fi

# parse positional args
declare Action=$1
declare Name='' # empty if Action=ACT_LIST
if [ $# -ge 2 ] ; then
	Name=$2
fi
shift 2

# parse optional args
declare Folder=''
declare -i Size=0
declare Device=''
declare Owner=''
declare KeyDev=''
declare KeyLabel=''
if [ $# -ne 0 ] ; then
	while getopts f:s:d:o:k:K: option
	do
		case $option in
		f) Folder=$OPTARG ;;
		s) Size=$OPTARG ;;
		d) Device=$OPTARG ;;
		o) Owner=$OPTARG ;;
		k) KeyDev=$OPTARG ;;
		K) KeyLabel=$OPTARG ;;
		*) usage ; exit 1;;
		esac
	done
	shift $((OPTIND -1)) 
fi

# Initializations
declare -i Exitval=0

# change to user's home dir in order to prevent errors like
# "find: Failed to restore initial working directory: /mnt/sshfs/enigma:59607/home/rigou/bin/backup: Permission denied"
# as a result, the -f folder option should specify an absolute path, or a path relative to the home dir
if ! cd "/home/${SUDO_USER:-$USER}" ; then
	print_line $stderr "WARNING: working directory is $(pwd)"
fi

if [ -n "$Name" ] ; then # ACT_LIST takes no args, hence Name is empty
	readonly DevMountPoint="/tmp/$APPNAME.dev"
	readonly KeyMountPoint="/tmp/$APPNAME.key"
	readonly LuksMountPoint="/mnt/$APPNAME/$Name"
	readonly LuksMap="/dev/mapper/$Name"
	declare BlockFile=''
	declare KeyFile=''
fi
if check_args ; then
	if [ -n "$Name" ] ; then
		KeyDev=$(get_key_device) # if option -K then use device from label else use device given by option -k
		if [ -n "$KeyDev" ] ; then 
			KeyFile="$KeyMountPoint/$APPNAME/$Name.key"
			mkdir -p "$KeyMountPoint"
		fi
		if [ -n "$Device" ] ; then 
			mkdir -p "$DevMountPoint"
		fi
		if [ -n "$Folder" ] ; then
			BlockFile="$Folder/$Name.dat"
		fi
		if ! [ -d "$LuksMountPoint" ] ; then
			mkdir -p "$LuksMountPoint"
		fi
	fi
	exec_action
	Exitval=$?
	
	# final cleanup
	if [ -n "$Name" ] ; then
		if [ -n "$Device" ] ; then 
			rmdir "$DevMountPoint"
		fi
		if [ -n "$KeyDev" ] ; then
			rmdir "$KeyMountPoint"
		fi
		if [ "$(get_volume_status)" != $GVS_MOUNTED ] ; then
			rmdir "$LuksMountPoint" 
		fi
	fi
	exit $Exitval
else
	exit 1
fi
