#!/bin/bash
# luksman : a simple manager for LUKS encrypted volumes
# download the latest version of this program : https://github.com/rigou/luksman/releases
#
# This program is free software: you can redistribute it and/or modify it under the terms
# of the GNU General Public License as published by the Free Software Foundation, version 3.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.
# See the GNU General Public License for more details : https://www.gnu.org/licenses/#GPL 
#
# Installation, usage : https://github.com/rigou/luksman/blob/main/README.md
# Run this script as root (sudo)

set -o nounset

readonly APPNAME='luksman'
readonly VERSION='1.4.0'

# output user-readable messages
declare -i DEBUG_ENABLED=1 # 1=enabled, 0=disabled
declare -i stdin=1
declare -i stderr=2
declare -i stdebug=3
function print_line {
	case $1 in
		"$stdin") echo "$2" ;;

		"$stderr") echo "$2" 1>&2 ;;

		"$stdebug") if [ $DEBUG_ENABLED -eq 1 ] ; then echo "DEBUG $2" 1>&2 ; fi ;;
	esac
}

# sanitize given name for fat32 compatibility
function sanitize_name {
    if [ -n "$1" ] ; then
	    local text=$1
		text="${text//$'\n'/}"
		text="${text//$'\r'/}"
		text="${text//\//}"
		text="${text//</}"
		text="${text//>/}"
		text="${text//:/}"
		text="${text//\"/}"
		text="${text//\\/}"
		text="${text//|/}"
		text="${text//\?/}"
		text="${text//\*/}"
		echo -n "$text"
    fi
}

function get_key_device {
	print_line $stdebug "get_key_device()"
	local keydev_from_label=''
	if [ -n "$KeyLabel" ] ; then
		keydev_from_label=$(readlink -fe "/dev/disk/by-label/$KeyLabel")
		if [ -n "$keydev_from_label" ] ; then
			echo "$keydev_from_label" # empty string if label not found
		fi
	elif [ -n "$KeyDev" ] ; then
		echo "$KeyDev"
	fi
}

function get_temp_keyfile {
	echo "$KeyFile.tmp"
}

function validate_temp_keyfile {
	print_line $stdin "validating new key file"
	mv -f "$(get_temp_keyfile)" "$KeyFile"
	return $?
}

# Store a randomly generated 33 char key in a file
# we create the key using a 90 ascii printable char set
# a 33 char key lengths gives 3 x 10^64 distinct keys
# Since v1.1.4 the key string is not terminated by \n, enabling us to enter it with the keyboard if so desired
# Lucks will use our key to unlock the master-key of the encrypted device
# (passphrases can be up to 512 characters and keyfiles up to 8192 KiB)
function create_temp_keyfile {
	print_line $stdebug "create_temp_keyfile()"
	local -i retval_int=0 # success
	local temp_keyfile ; temp_keyfile=$(get_temp_keyfile)
	print_line $stdin "generating new key file"
	local key ; key=$(LC_ALL=C tr -dc 'A-Za-z0-9_\+\-*/=,?;.:/!$&#{[|]}@%&$"~^' < /dev/random | head -c 33)
	mkdir -p "$(dirname "$temp_keyfile")"
	if ! echo -n "$key" >"$temp_keyfile" ; then
		retval_int=1 # error
	fi
	return $retval_int
}

function mount_key {
	print_line $stdebug "mount_key()"
	local -i retval_int=0 # 0=success, 1=error
	if ! mountpoint -q "$KeyMountPoint" ; then
		mount "$KeyDev" "$KeyMountPoint"
		retval_int=$?
	fi
	return $retval_int
}

function unmount_key {
	print_line $stdebug "unmount_key()"
	local -i retval_int=0 # 0=success, 1=error
	if mountpoint -q "$KeyMountPoint" ; then
		rm -f "$(get_temp_keyfile)" # just in case
		umount "$KeyMountPoint"
		retval_int=$?
	else
		print_line $stderr "key not found at $KeyMountPoint"
		retval_int=0 # ignore this error
	fi
	return $retval_int
}

# print the path of the file container of attached volume Name
# or nothing if none (volume resides in a disk partition, or is not attached, or does not exist)
function get_file_container {
	print_line $stdebug "get_file_container()"
	losetup --output BACK-FILE --noheadings |grep "/$1.dat"
}

# print the loop device of attached volume Name
# or nothing if none (volume resides in a disk partition, or is not attached, or does not exist)
function get_loop_device {
	print_line $stdebug "get_loop_device()"
	local file_container=''
	file_container=$(get_file_container "$1")
	if [ -n "$file_container" ] ; then
		losetup -j "$file_container" --output NAME --noheadings # /dev/loop0
	fi
}

# Tell if given volume name corresponds to an attached loop device
# Return value: 0=attached, 1=not attached or not a loop device
function is_attached_file_container {
	print_line $stdebug "is_attached_file_container()"
	local -i retval_int=0
	if [ -z "$(get_loop_device "$1")" ] ; then
		retval_int=1
	fi
	return $retval_int
}
	
# Return values written on stdout: 			
declare -ir GVS_CLOSED=0
declare -ir GVS_MOUNTED=1	# encrypted filesystem mounted, ready for use
declare -ir GVS_FAILED1=2	# file container attached (if any), no LUKS open
declare -ir GVS_FAILED2=3	# file container attached (if any) and LUKS open but filesystem not mounted
function get_volume_status {
	print_line $stdebug "get_volume_status()"
	local -i retval_int=$GVS_CLOSED
	local -i attached_bool=0 # 0=false, 1=true
	local -i luksopen_bool=0
	local -i mounted_bool=0
	if is_attached_file_container "$Name" ; then
		attached_bool=1
	fi
	if [ -b "$LuksMap" ] ; then
		luksopen_bool=1
	fi
	if mountpoint -q "$LuksMountPoint" ; then
		mounted_bool=1
	fi
	if [ $mounted_bool -eq 1 ] ; then
		retval_int=$GVS_MOUNTED
	else
		if [ $luksopen_bool -eq 1 ] ; then
			retval_int=$GVS_FAILED2
		elif [ $attached_bool -eq 1 ] ; then
			retval_int=$GVS_FAILED1
		fi
	fi
	echo $retval_int
}

# return value: writes the device name on stdout, or 'ERROR'
function attach_file_container {
	print_line $stdebug "attach_file_container()"
	if [ -f "$FileContainer" ] ; then
		if ! is_attached_file_container "$Name" ; then
			print_line $stderr "attaching $FileContainer"
			# The loop device setup is not an atomic operation when used with --find, 
			# and losetup does not protect this operation by any lock.
			# It is recommended to use flock(1) to avoid a collision in heavily parallel use cases
			# with error like "losetup: failed to set up loop device: Device or resource busy"
			local luks_dev=''
			exec 4<>"/var/lock/$APPNAME-losetup.lock" # open this file with descriptor 4
			# allow for a 10 seconds timeout to get a lock on this file
			if flock --wait 10 4 ; then
				# got lock
				if luks_dev=$(losetup --find --nooverlap) ; then # something like /dev/loop0
					if ! losetup "$luks_dev" "$FileContainer" ; then
						luks_dev='ERROR'
					fi
				else
					luks_dev='ERROR'
				fi
			else
				luks_dev='ERROR' # failed to obtain lock
			fi
			exec 4>&- # close the file to unlock it
			echo "$luks_dev"
		else
			print_line $stderr "$Name is already attached"
			echo 'ERROR'
		fi
	else
		print_line $stderr "file not found $FileContainer"
		echo 'ERROR'
	fi
	return
}

function detach_file_container {
	print_line $stdebug "detach_file_container()"
	retval_int=0 # success
	if is_attached_file_container "$Name" ; then
		print_line $stdin "detaching $(get_file_container "$Name")"
		local luks_dev=''
		luks_dev=$(get_loop_device "$Name")
		if [ -n "$luks_dev" ] ; then
			if ! losetup -d "$luks_dev" ; then
				retval_int=4 # error
			fi
		else
			retval_int=3 # error
		fi
	else
		retval_int=2 # error
	fi
	return $retval_int
}

function create_luks {
	print_line $stdebug "create_luks()"
	local -i retval_int=0 # success
	local luks_dev=''
	local -i attached_bool=0 # 0=false, 1=true
	local -i luksopen_bool=0 # 0=false, 1=true
	local -i keydev_mounted_bool=0 # 0=false, 1=true

	# test for existing file container with same name
	if [ -n "$FileContainer" ] && [ -f "$FileContainer" ] ; then
		print_line $stderr "can not create volume $Name because file $FileContainer already exists"
		print_line $stderr "you should delete it if you want to create another volume with the same name" 
		retval_int=1 # error
	fi

	# test for existing key file with same name
	if [ -n "$KeyDev" ] ; then
		if mount_key ; then
			keydev_mounted_bool=1
			if [ -f "$KeyFile" ] ; then
				local key_name=$KeyLabel
				if [ -z "$key_name" ] ; then
					key_name=$KeyDev
				fi
				print_line $stderr "can not create volume $Name because key file $(basename "$KeyFile") already exists"
				print_line $stderr "you should delete it from $key_name if you want to create another volume with the same name" 
				retval_int=1 # error
			fi
		else
			retval_int=1 # error
		fi
	fi

	# test for existing filesystem on the device
	if [ $retval_int -eq 0 ] && [ -n "$Device" ] ; then
		if mount -r "$Device" "$DevMountPoint" 2>/dev/null ; then
			print_line $stdin "$Device appears to contain an existing filesystem ($(findmnt -n -o FSTYPE "$DevMountPoint")) : it will be deleted"
			umount "$DevMountPoint"
			while : ; do
				read -r -p "are you sure (YES/no) ? " yn
				case $yn in
					YES) retval_int=0 ; break ;;
					no) retval_int=1 ; break ;;
					*) print_line $stdin "please answer YES or no" ;;
				esac
			done
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if [ -n "$FileContainer" ] ; then
			print_line $stdin "assigning $FileContainer to $Owner"
			touch "$FileContainer"
			chown "$Owner": "$FileContainer" 2>/dev/null # silently fails with Fat/exFat filesystems
			print_line $stdin "overwriting $FileContainer with $Size MiB random data"
			# option conv=fsync used to prevent possible premature device removal
			if dd if=/dev/urandom of="$FileContainer" bs=1M count=$Size conv=fsync status=progress ; then
				luks_dev=$(attach_file_container)
				if [ "$luks_dev" != 'ERROR'  ] ; then
					attached_bool=1 # true
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		else
			luks_dev=$Device
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if [ -n "$KeyDev" ] ; then
			if create_temp_keyfile ; then
				print_line $stdin "formatting $Name"
				if cryptsetup luksFormat --key-file="$(get_temp_keyfile)" -q "$luks_dev" ; then
					if cryptsetup open --type luks --key-file="$(get_temp_keyfile)" "$luks_dev" "$Name" ; then
						luksopen_bool=1
					else
						retval_int=1 # error
					fi
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		else
			print_line $stdin "formatting $Name"
			if cryptsetup luksFormat -q  "$luks_dev" ; then
				if cryptsetup open --type luks "$luks_dev" "$Name" ; then
					luksopen_bool=1
				else
					retval_int=1 # error
				fi
			else
				retval_int=1 # error
			fi
		fi
	fi

	if [ $retval_int -eq 0 ] ; then
		if mkfs -t ext4 -L "$Name" "$LuksMap" ; then
			print_line $stdin "assigning $Name to $Owner"
			if mount "$LuksMap" "$LuksMountPoint" ; then
				chown "$Owner": "$LuksMountPoint"
				retval_int=$?
				umount "$LuksMountPoint"
				# take a short nap after umount because sometimes (under high system load) cryptsetup close would fail
				# with "device-mapper: remove ioctl on PRO  failed: Device or resource busy"
				sleep 2
			else
				retval_int=1 # error
			fi
		else
			retval_int=1 # error
		fi
	fi

	if [ $luksopen_bool -eq 1 ] ; then
		cryptsetup close "$LuksMap"
	fi
	if [ $attached_bool -eq 1 ] ; then
		detach_file_container
	fi
	if [ -n "$KeyDev" ] ; then
		if [ $retval_int -eq 0 ] ; then
			validate_temp_keyfile
			retval_int=$?
		fi
	fi
	if [ $keydev_mounted_bool -eq 1 ] ; then
		unmount_key
	fi
	if [ $retval_int -eq 0 ] ; then
		print_line $stdin "volume $Name is created"
	fi
	return $retval_int
}

function add_or_replace_key {
	print_line $stdebug "add_or_replace_key()"
	local -i retval_int=0 # success
	local luks_dev=''
	local -i attached_bool=0 # 0=false, 1=true
	if mount_key ; then
		if [ -n "$FileContainer" ] ; then
			luks_dev=$(attach_file_container) # /dev/loop0
			if [ "$luks_dev" != 'ERROR'  ] ; then
				attached_bool=1 # true
			else
				retval_int=1 # error
			fi
		else
			luks_dev=$Device
		fi
		if [ $retval_int -eq 0 ] ; then
			if ! create_temp_keyfile ; then
				retval_int=1 # error
			fi
		fi
		if  [ $retval_int -eq 0 ] ; then
			if [ -f "$KeyFile" ] ; then
				print_line $stdin "replacing key file"
				if cryptsetup luksAddKey "$luks_dev"  --key-file "$KeyFile" "$(get_temp_keyfile)" ; then
					print_line $stdin "removing old key"
					if ! cryptsetup luksRemoveKey "$luks_dev" "$KeyFile" ; then
						print_line $stderr "WARNING: failed to remove old key for $Name"
					fi
					print_line $stdin "key replaced for $Name"
				else
					retval_int=1 # error
				fi
			else
				print_line $stdin "adding key file"
				if cryptsetup luksAddKey "$luks_dev" "$(get_temp_keyfile)" ; then
					print_line $stdin "removing old passphrase (enter invalid value to preserve it)"
					if ! cryptsetup luksRemoveKey "$luks_dev"  ; then
						print_line $stderr "WARNING: did not remove old key for $Name"
					fi
					print_line $stdin "key added to $Name"
				else
					retval_int=1 # error
				fi
			fi
		fi
		if [ $attached_bool -eq 1 ] ; then
			detach_file_container
		fi
		if [ $retval_int -eq 0 ] ; then
			validate_temp_keyfile
			retval_int=$?
		fi
		unmount_key
	else
		retval_int=1 # error
	fi
	if [ $retval_int -eq 0 ] ; then
		print_line $stdin "key registration complete"
	fi
	return $retval_int
}

function mount_luks {
	print_line $stdebug "mount_luks()"
	local -i retval_int=0 # success
	local -i key_mounted_bool=0 # 0=false 1=true
	if [ -n "$KeyDev" ] ; then
		if mount_key ; then
			key_mounted_bool=1
			if ! [ -f "$KeyFile" ] ; then
				print_line $stderr "key file not found for $Name"
				retval_int=1
			fi
		else
			retval_int=1
		fi
	fi
	if  [ $retval_int -eq 0 ] ; then
		if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			local luks_dev=''
			if  [ $retval_int -eq 0 ] ; then
				if [ -n "$FileContainer" ] ; then
					luks_dev=$(attach_file_container) # /dev/loop0
					if [ "$luks_dev" = 'ERROR'  ] ; then
						retval_int=1
					fi
				else
					luks_dev=$Device
				fi
			fi
			if  [ $retval_int -eq 0 ] ; then
				print_line $stdin "opening $Name"
				if [ -n "$KeyDev" ] ; then
					cryptsetup open --type luks --key-file="$KeyFile" "$luks_dev" "$Name"
				else
					cryptsetup open --type luks "$luks_dev" "$Name"
				fi
				retval_int=$?
				if [ $retval_int -eq 0 ] ; then
					print_line $stdin "mounting $Name"
					mount "$LuksMap" "$LuksMountPoint"
					retval_int=$?
				fi
			fi
			
		fi
	fi
	if [ $key_mounted_bool -eq 1 ] ; then
		unmount_key
	fi
	print_info
	return $retval_int
}

# unmounting an encrypted volume is a 3 steps process
function unmount_luks {
	print_line $stdebug "unmount_luks()"
	local -i retval_int=0 # success
	local -i status_int=0; status_int=$(get_volume_status)

	case $status_int in

	"$GVS_MOUNTED") # unmount step 1 : encrypted filesystem mounted
		print_line $stdin "unmounting $Name"
		if umount "$LuksMountPoint" ; then
			# take a short nap after umount because sometimes cryptsetup close would fail
			# with "device-mapper: remove ioctl on PRO  failed: Device or resource busy"
			sleep 2
			unmount_luks # recursive call to case GVS_FAILED2
			retval_int=$?
		else
			# list open files, if any
			lsof +d "$LuksMountPoint" 2>/dev/null ; retval_int=1
			retval_int=1 # error
			print_line $stdebug "unmount_luks() failed, error $retval_int"
		fi
		print_info
		;;

	"$GVS_FAILED2") # unmount step 2 : file container attached (if any) and LUKS open but filesystem not mounted
		print_line $stdin "closing $LuksMap"
		if cryptsetup close "$LuksMap" ; then
			unmount_luks # recursive call to case GVS_FAILED1
			retval_int=$?
		else
			retval_int=2 # error
			print_line $stdebug "unmount_luks() failed, error $retval_int"
		fi
		;;

	"$GVS_FAILED1") # unmount step 3 : file container attached, no LUKS open
		print_line $stdin "detaching $LuksMap"
		if detach_file_container ; then
			retval_int=0
		else
			retval_int=3 # error
			print_line $stdebug "unmount_luks() failed, error $retval_int"
		fi
		;;

	"$GVS_CLOSED") # encrypted filesystem unmounted
		retval_int=0
		;;
	esac

	return $retval_int
}

function delete_luks {
	print_line $stdebug "delete_luks()"
	local -i retval_int=0 # success

	if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
		# Confirm that the deletion candidate is actually a LUKS volume
		if mount_luks ; then
			# take a short nap after mount because sometimes (under high system load) umount would fail
			# with "umount: /mnt/luksman/TEST01-28240: target is busy."
			sleep 2
			# unmount the encrypted filesystem and close the LUKS object
			if umount "$LuksMountPoint" ; then
				if cryptsetup close "$LuksMap" ; then
					# locate the LUKS storage area
					local luks_dev=''
					if [ -n "$FileContainer" ] ; then
						luks_dev=$(get_loop_device "$Name")
					else
						luks_dev=$Device
					fi
					# overwrite the LUKS storage area with some random data
					# TODO : a better way to wipe a LUKS header is to use the luksErase command
					local -ri rnd_length=20 # MiB
					print_line $stdin "overwriting $luks_dev with $rnd_length MiB random data" 
					if ! dd if=/dev/urandom of="$luks_dev" bs=1M count=$rnd_length conv=fsync ; then 
						retval_int=7 # error
					fi
					if is_attached_file_container "$Name" ; then
						if detach_file_container ; then 
							print_line $stdin "deleting $FileContainer"
							if ! rm "$FileContainer" ; then
								retval_int=6 # error
							fi
						else
							retval_int=5 # error
						fi
					fi
				else
					retval_int=4 # error
				fi
			else
				retval_int=3 # error
			fi
		else
			retval_int=2 # error
		fi
	else
		retval_int=1 # error
	fi

	if  [ $retval_int -eq 0 ] ; then
		if [ -n "$KeyDev" ] ; then
			if mount_key ; then
				print_line $stdin "deleting $(basename "$KeyFile")"
				if ! rm "$KeyFile" ; then
					retval_int=12
				fi
				unmount_key
			else
				retval_int=11
			fi
		fi
	fi
	
	if  [ $retval_int -eq 0 ] ; then
		print_line $stdin "$Name is deleted"
	else
		print_info
		print_line $stdin "did not delete $Name, error $retval_int"
	fi
	return $retval_int
}

function print_info {
	print_line $stdebug "print_info()"
	local -i status_int ; status_int=$(get_volume_status)
	local open_text=''
	case $status_int in
	"$GVS_CLOSED") open_text="not mounted" ;;
	"$GVS_MOUNTED") open_text="mounted at $LuksMountPoint" ;;
	"$GVS_FAILED1") open_text="in failed state : loop device attached but LUKS not open" ;;
	"$GVS_FAILED2") open_text="in failed state : LUKS open but filesystem not mounted" ;;
	esac
	open_text="$Name is $open_text"
	if [ $status_int -eq  $GVS_FAILED1 ] || [ $status_int -eq  $GVS_FAILED2 ] ; then
		print_line $stderr "$open_text"
		print_line $stderr "try \"$(basename "$0") unmount $Name\" to fix this error"
	else
		print_line $stdin "$open_text"
	fi
}

function print_list {
	print_line $stdebug "print_list()"
	local path=''
	find /dev/mapper -type l -print0 |while IFS= read -r -d '' path
	do
		local mountpoint ; mountpoint="/mnt/$APPNAME/$(basename "$path")"
		if [ -d "$mountpoint" ] ; then
			print_line $stdin "$mountpoint"
		fi
	done
}

function exec_action {
	print_line $stdebug "exec_action($Action)"
	local -i retval_int=0 # success
	case "$Action" in
	"$ACT_CREATE") if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			create_luks
			retval_int=$?
		else
			print_line $stderr "$Name is in use : unmount it first with \"$(basename "$0") unmount $Name\""
			retval_int=1
		fi
		;;
	"$ACT_NEWKEY") if [ "$(get_volume_status)" -eq $GVS_CLOSED ] ; then
			add_or_replace_key
			retval_int=$?
		else
			print_line $stderr "$Name is in use : unmount it before adding/replacing a key"
			retval_int=1
		fi
		;;
	"$ACT_MOUNT")
		mount_luks
		retval_int=$?
		;;
	"$ACT_UNMOUNT")
		if [ "$Name" = 'all' ] ; then
			local mounted_volumes='' ; mounted_volumes=$(print_list)
			if [ -n "$mounted_volumes" ] ; then
				while IFS= read -r mounted_volume ; do
					"$0" unmount "$(basename "$mounted_volume")"
					retval_int+=$?
				done <<< "$mounted_volumes"
			fi
		else
			unmount_luks
			retval_int=$?
		fi
		;;
	"$ACT_DELETE")
		delete_luks
		retval_int=$?
		;;
	"$ACT_INFO") print_info ; retval_int=0 ;;
	"$ACT_LIST") print_list ; retval_int=0 ;;
	esac
	return $retval_int
}

function usage {
	print_line $stdin "$APPNAME v$VERSION usage"
	local n0="    $APPNAME"
	print_line $stdin "create volume in a file container or a device"
	print_line $stdin "$n0 $ACT_CREATE name (-f folder -s size_MiB | -d device) [(-k keyfile_device | -l keyfile_disk_label)] -o owner_name "
	print_line $stdin "add or replace a key file"
	print_line $stdin "$n0 $ACT_NEWKEY name (-f folder | -d device) (-k keyfile_device | -l keyfile_disk_label)"
	print_line $stdin "mount volume"
	print_line $stdin "$n0 $ACT_MOUNT name (-f folder | -d device) [(-k keyfile_device | -l keyfile_disk_label)]"
	print_line $stdin "unmount volume(s)"
	print_line $stdin "$n0 $ACT_UNMOUNT (name | all)"
	print_line $stdin "delete volume"
	print_line $stdin "$n0 $ACT_DELETE name (-f folder | -d device) [(-k keyfile_device | -l keyfile_disk_label)]"
	print_line $stdin "print volume information"
	print_line $stdin "$n0 $ACT_INFO name"
	print_line $stdin "list mounted volumes"
	print_line $stdin "$n0 $ACT_LIST"
}

function check_args {
	print_line $stdebug "check_args($Action $Name)"
	local -i retval_int=1 # error
	local -ri VOLUME_MIN_SIZE=17 # because LUKS takes a 16 MiB overhead
	if [ "$Action" = $ACT_LIST ] ; then
		retval_int=0 # list takes no args
	elif [ -n "$Name" ] ; then
		# check Name
		local filtered_name='' ; filtered_name=$(sanitize_name "$Name")
		if [ "$filtered_name" = "$Name" ] ; then
			# check required arguments
			case "$Action" in
			"$ACT_CREATE") if [ -n "$Folder" ] && [ -z "$Device" ] && [ $Size -ge $VOLUME_MIN_SIZE ] && [ -n "$Owner" ] ; then retval_int=0 ; fi
				if [ -n "$Device" ] && [ -z "$Folder" ] && [ -n "$Owner" ] ; then retval_int=0 ; fi
				;;
			"$ACT_NEWKEY") if [ -n "$Folder" ] && [ -z "$Device" ] && [ -n "$KeyDev" ] &&  [ -z "$KeyLabel" ] ; then retval_int=0 ; fi
				if [ -n "$Folder" ] && [ -z "$Device" ] && [ -z "$KeyDev" ] &&  [ -n "$KeyLabel" ] ; then retval_int=0 ; fi
				if [ -n "$Device" ] && [ -z "$Folder" ] && [ -n "$KeyDev" ] &&  [ -z "$KeyLabel" ] ; then retval_int=0 ; fi
				if [ -n "$Device" ] && [ -z "$Folder" ] && [ -z "$KeyDev" ] &&  [ -n "$KeyLabel" ] ; then retval_int=0 ; fi
				;;
			"$ACT_MOUNT" | "$ACT_DELETE") if [ -n "$Folder" ] && [ -z "$Device" ] ; then retval_int=0 ; fi
				if [ -n "$Device" ] && [ -z "$Folder" ] ; then retval_int=0 ; fi
				;;
			"$ACT_UNMOUNT" | "$ACT_INFO") retval_int=0 ;;
			esac
			if [ $retval_int -eq 0 ] ; then
				# check optional arguments -k -l
				if [ -n "$KeyDev" ] && [ -n "$KeyLabel" ] ; then retval_int=1 ; fi
				if [ -n "$KeyDev" ] || [ -n "$KeyLabel" ] ; then
					if [ "$Action" = "$ACT_UNMOUNT" ] || [ "$Action" = "$ACT_INFO" ] ; then
						retval_int=1
					fi
				fi
			fi
			if [ $retval_int -ne 0 ] ; then 
				print_line $stderr "missing/extra/invalid arg"
			fi
		else
			print_line $stderr "$Name contains illegal character(s)"
			retval_int=1
		fi
	fi
	if [ $retval_int -eq 0 ] ; then 
		if [ -n "$Folder" ] && ! [ -d "$Folder" ] ; then print_line $stderr "folder $Folder not found" ; retval_int=2 ; fi
		if [ -n "$Device" ] && ! [ -b "$Device" ] ; then print_line $stderr "device $Device not found" ; retval_int=2 ; fi
		if [ -n "$KeyDev" ] && ! [ -b "$KeyDev" ] ; then print_line $stderr "device $KeyDev not found" ; retval_int=2 ; fi
		if [ -n "$Owner" ] && ! id "$Owner" 1>/dev/null 2>&1 ; then print_line $stderr "user $Owner not found" ; retval_int=2 ; fi
		if [ -n "$KeyLabel" ] ; then
			# get_key_device() returns empty string if label not found
			if [ -z "$(get_key_device)" ] ; then
				print_line $stderr "device not found with label $KeyLabel"
				retval_int=2
			fi
		fi
	fi
	return $retval_int
}

# BEGIN ----------

if [ "$(id -u)" != '0' ] ; then
	print_line $stderr "$APPNAME must run as root, run it with sudo $APPNAME"
	exit 1
fi

# Parse command line args
readonly ACT_CREATE='create'
readonly ACT_NEWKEY='newkey'
readonly ACT_MOUNT='mount'
readonly ACT_UNMOUNT='unmount'
readonly ACT_DELETE='delete'
readonly ACT_INFO='info'
readonly ACT_LIST='list'
if [ $# -eq 0 ] ; then
	usage
	exit 1
fi

# parse positional args
declare Action=$1
declare Name='' # empty if Action=ACT_LIST
if [ $# -ge 2 ] ; then
	Name=$2
fi
shift 2

# parse optional args
declare Folder=''
declare -i Size=0
declare Device=''
declare Owner=''
declare KeyDev=''
declare KeyLabel=''
if [ $# -ne 0 ] ; then
	while getopts f:s:d:o:k:l: option
	do
		case $option in
		f) Folder=$OPTARG ;;
		s) Size=$OPTARG ;;
		d) Device=$OPTARG ;;
		o) Owner=$OPTARG ;;
		k) KeyDev=$OPTARG ;;
		l) KeyLabel=$OPTARG ;;
		*) usage ; exit 1;;
		esac
	done
	shift $((OPTIND -1)) 
fi

# Initializations
declare -i Exitval=0

# change to user's home dir in order to prevent errors like
# "find: Failed to restore initial working directory: /mnt/sshfs/enigma:59607/home/rigou/bin/backup: Permission denied"
# as a result, the -f folder option should specify an absolute path, or a path relative to the home dir
if ! cd "/home/${SUDO_USER:-$USER}" ; then
	print_line $stderr "WARNING: working directory is $(pwd)"
fi

if [ -n "$Name" ] ; then # ACT_LIST takes no args, hence Name is empty
	readonly DevMountPoint="/tmp/$APPNAME-$$.dev"
	readonly KeyMountPoint="/tmp/$APPNAME-$$.key"
	readonly LuksMountPoint="/mnt/$APPNAME/$Name"
	readonly LuksMap="/dev/mapper/$Name"
	declare FileContainer=''
	declare KeyFile=''
fi
if check_args ; then
	if [ -n "$Name" ] ; then
		KeyDev=$(get_key_device) # if option -l then use device from label else use device given by option -k
		if [ -n "$KeyDev" ] ; then 
			KeyFile="$KeyMountPoint/$APPNAME/$Name.key"
			mkdir -p "$KeyMountPoint"
		fi
		if [ -n "$Device" ] ; then 
			mkdir -p "$DevMountPoint"
		fi
		if [ -n "$Folder" ] ; then
			FileContainer="$Folder/$Name.dat"
		fi
		if ! [ -d "$LuksMountPoint" ] ; then
			mkdir -p "$LuksMountPoint"
		fi
	fi
	exec_action
	Exitval=$?
	
	# final cleanup
	if [ -n "$Name" ] ; then
		if [ -n "$Device" ] ; then 
			rmdir "$DevMountPoint"
		fi
		if [ -n "$KeyDev" ] ; then
			rmdir "$KeyMountPoint"
		fi
		if [ "$(get_volume_status)" != $GVS_MOUNTED ] ; then
			rmdir "$LuksMountPoint" 
		fi
	fi
	exit $Exitval
else
	exit 1
fi
